---
layout: post
title: GUIDs As Identifiers
comments: true
---

<p>In most applications, database tables use ints (or maybe longs if you have a large app) as their primary keys. And why not? They're dead simple. Most databases have a mechanism with which they can auto-generate these IDs, they're a native language construct in every language imaginable and they work. They're also small data types - 4 bytes for an integer - so they don't take up too much space and perform slightly faster when you query.</p>

<p>GUIDs, however, have some benefits that are hard to ignore. And in fact, when building an SOA system with business capabilities that are autonomous, it's actually easier to use them than what you're used to.</p>

<p>The biggest benefit from an SOA standpoint is that they are generated on the client rather than the server. This means you don't have to go to the database to get the next available ID. That's quite important. If you've read my previous post about splitting up BCs, you should be aware of the idea that "there is no THE product" or "there is no THE customer" or maybe in our context, "there is no THE agreement". The data that makes up an agreement may actually be spreadout amongst multiple business capabilities. And while we will not make a foreign key reference to the data in another BC, you will need an identifier that lets you know that you're working with the same concept.</p>

<p>Let's go back to the Customer -> CustomerStatus -> Product example from a previous post. The Customer will need an ID and you will need to know that ID in the CustomerStatus object as well, even if they're in different BCs. If each BCs data store manages their ID generation, it's going to be extremely difficult to make that work. If you generate an ID on the client, however, and include it in the message, it becomes much more simple. When you're creating a new customer, it'll be much easier to generate an ID on the client and then include it in command messages to both the Customer object and the CustomerStatus object.</p>

<p>Another nice benefit of GUIDs is right in the name - they are GLOBALLY unique. That means that the id given to an entity in your system is globally unique to that entity, not just other entities of the same type. In concrete terms, imagine you have an Agreement with ID = 1 and a MarginCall with ID = 1. That happens fairly frequently. Not the case when using GUIDs. Your agreement will have an ID that is unique throughout the entirety of the system. That is useful. Anywhere that GUID is in your data, you can trace it back to the exact entity thta it relates to. There's no chance of seeing an ID = 5 and needing extra information to determine WHICH entity type it is referring to.</p>

<p>A final benefit of using GUIDs is that as soon as data enters your system, you can identify it. This is not the case with db-generated ids. Until first save, you can have a new entity in your system that has no identity. That's a strange thing to think about. The flip side of the argument is that until it's saved, does it really exist? With GUIDs, discarding one you generated is not a big deal. You're not really wasting something that you have such a large supply of. But think about our system. Before an agreement is approved, it has no id. That's how we represent an unapproved agreement in our system. I'm not sure if the agreement has an id that we just don't map to the ResponseMessage or if it doesn't have one in the DB (my guess is the former), but in either case - the agreement does exist as an entity in our application and actions can be taken on it and it doesn't have any identifier. An unapproved agreement is SOMETHING in our system - it should be represented as such.</p>

<p>A few things to note. When people first hear about generating on the client, they have a few concerns. The first being the chance of collision - meaning the worry that the client may generate the same GUID twice. Taken from the wikipedia page on GUIDs, "Assuming uniform probability for simplicity and that every second, every person on earth generated one million GUIDs, it would statistically take far longer than the current age of the universe to generate two identical GUIDs." I feel pretty confident in that.</p>

<p>The other concern is that ints can be indexed better and perform better in JOINs when querying the database. This is true. But remember - if you've done SOA correctly, you won't be running joins on data outside of your BC so this is negligible. And yes, they do take up more space in the database for sure, but space is pretty cheap these days.</p>

<p>So think about GUIDs for ids. They're not ONLY for databases that hold more data than your int/long data type can support. They're going to give you benefits which make moving to SOA much easier.</p>
